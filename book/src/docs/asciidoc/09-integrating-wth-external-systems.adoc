ifndef::imagesdir[:imagesdir: images]
== Integrating with External Systems (15 pages)
[quote, Carl Jung]
Wholeness is not achieved by cutting off a portion of one's being, but by integration of the contraries.

Thus far, we have used DDD to implement a robust core for our application. However, most bounded contexts usually have both upstream and downstream dependencies which usually change at a pace which is different from these core components. To maintain both agility and reliability  and enable loose coupling, it is important to create what DDD calls the anti-corruption layer in order to shield the core from everything that surrounds it. In this chapter, we will look at integrating with a legacy Inventory Management system. We will round off by looking at common patterns when integrating with legacy applications.

=== Technical Requirements

=== Continuing our design journey
From our eventstorming session, we have arrived at four bounded contexts for our application as depicted here:

[.text-center]
[plantuml,lc-application]
....
@startuml
skinparam CloudFontName "Gloria Hallelujah"
skinparam handwritten true

cloud "LC Issuance" as issuance {
  cloud LC
}
cloud "LC Application Processing" {
  cloud "LC Application" as App {
    cloud Merchandise as p1
    cloud Applicant
  }
}
cloud Compliance {
  cloud Product as p2
}
cloud "Customer Onboarding" as onboarding {
  cloud Customer as customer
}
LC <-> App
p1 <-> p2
Applicant <--> customer

@enduml
....


.A simple context map for the LC application
[.text-center]
image::lc-application-context-map.png[]

=== Integration mechanisms

==== Symmetric relationship patterns

===== Partnership

===== Shared kernel

===== Separate ways

==== Asymmetric relationship patterns

===== Conformist

===== Anti-corruption layer

===== Open host service

=== Implementation patterns

==== Data-based

==== API-based

===== HTTP-based APIs

===== Message-based APIs

==== Shared code artifacts

==== Enforcing contracts

=== Legacy Application Migration Patterns

