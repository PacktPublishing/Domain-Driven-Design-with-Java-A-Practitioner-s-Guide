ifndef::imagesdir[:imagesdir: images]
[.text-justify]

== Implementing Queries and Projections (10 pages)
[quote, Anonymous]
The best view comes after the hardest climb.

In the section on <<command-query-responsibility-segregation-cqrs,CQRS>>, we described how DDD and CQRS complement each other and how the query side (read models) can be used to create one or more representations of the underlying data. In this chapter, we will dive deeper into how we can construct read optimized representations of the data by listening to domain events. We will also look at persistence options for these read models.

When working with query models, we construct models by listening to events as they happen. We will examine how to deal with situations where:

* New requirements evolve over a period of time requiring us to build new query models.
* We discover a bug in our query model which requires us to recreate the model from scratch.

=== Technical requirements
* JDK 1.8+ (We have used Java 16 to compile sample sources)
* JavaFX SDK 16 and SceneBuilder
* Spring Boot 2.4.x
* mvvmFX 1.8 (https://sialcasa.github.io/mvvmFX/)
* JUnit 5.7.x (Included with spring boot)
* TestFX (for UI testing)
* OpenJFX Monocle (for headless UI testing)
* Project Lombok (To reduce verbosity)
* Axon server to act as an event store
* Maven 3.x

=== Continuing our design journey
In <<_domain_analysis_and_modeling,Chapter 4 - Domain analysis and modeling>>, we discussed eventstorming as a lightweight method to clarify business flows. As a reminder, this is the output produced from our eventstorming session:

.Recap of eventstorming session
[.text-center]
image::event-storming/05-query-models.png[]

As mentioned previously, we are making use of the CQRS architecture pattern to create the solution. For a detailed explanation on why this is a sound method to employ, please refer to the "<<_when_to_use_cqrs, When to use CQRS>>" section in <<_where_does_ddd_fit,Chapter 3>>. In the diagram above, the *green* stickies represent *read/query models*. These query models are required when validating a command (for example: list of valid product identifiers when processing the `ValidateProduct` command) or if information is simply required to be presented to the user (for example: a list of LCs created by an applicant). Letâ€™s look at what it means to apply CQRS in practical terms for the query side.

=== Implementing the query side
In <<_implementing_the_command_side,Chapter 5>>, we examined how to publish events when a command is successfully processed. Now, let's look at how we can construct a query model by listening to these domain events. Logically, this will look something like how it is depicted here:

.CQRS application -- query side
[.text-center]
image::cqrs/cqrs-query-side.png[]

NOTE: Please refer to the section on <<_implementing_the_command_side, implementing the command side>> in Chapter 5 for a detailed explanation of how the command side is implemented.

The high level sequence on the query side is described here:

1. An event listening component listens to these domain events published on the event bus.
2. Constructs a purpose-built query model to satisfy a specific query use case.
3. This query model is persisted in a datastore optimized for read operations.
4. This query model is then exposed in the form of an API.

NOTE: Note how there can exist more than one query side component to handle respective scenarios.

Let's implement each of these steps to see how this works for our LC issuance application.

==== Tooling choices

In a CQRS application, there is a separation between the command and query side. At this time, this separation is logical in our application because both the command and query side are running as components within the same application process. To illustrate the concepts, we will use conveniences provided by the Axon framework to implement the query side in this chapter. In Chapter 10, we will look at how it may not be necessary to use a specialized framework (like Axon) to implement the query side.

When implementing the query side, we have two concerns to solve for:

1. Consuming domain events and persisting one or more query models.
2. Exposing the query model as an API.

.Query side dissected
[.text-center]
image::cqrs/cqrs-query-side-dissected.png[]

Before we start implementing these concerns, let's identify the queries we need to implement for our LC issuance application.

==== Identifying queries
From the eventstorming session, we have the following queries to start with:

.Identified queries
[.text-center]
[plantuml,potential-commands]
....
@startuml
skinparam handwritten true
skinparam CloudFontName "Gloria Hallelujah"
skinparam CloudFontSize 24
cloud "Queries\n" {
    cloud "Draft LC application"
    cloud "Approved Product Identifiers"
    cloud "Applicant Identifiers"
    cloud "List of LC applications\npending product validation"
    cloud "List of LC applications\npending applicant validation"
    cloud "List of LC applications\npending approval"
    cloud "List of approved\nLC applications"
}
@enduml
....

The queries marked in green, all require us to expose a collection of LCs in various states. To represent this, we can create an `LCView` as shown here:

The `LCView` class is an extremely simple object devoid of any logic.
[source,java,linenum]
....
public class LCView {

    private LCApplicationId id;
    private String applicantId;
    private String clientReference;
    private LCState state;

    // Getters and setters omitted for brevity
}
....

These query models are an absolute necessity to implement basic functionality dictated by business requirements. But it is possible and very likely that we will need additional query models as the system requirements evolve. We will enhance our application to support these queries as and when the need arises.


==== Creating the query model

As seen in chapter 5, when starting a new LC application, the importer sends a `StartNewLCApplicationCommand`, which results in the `LCApplicationStartedEvent` being emitted as shown here:

[source,java,linenum]
....
class LCApplication {
    //..
    @CommandHandler
    public LCApplication(StartNewLCApplicationCommand command) {
        // Validation code omitted for brevity
        // Refer to chapter 5 for details.
        AggregateLifecycle.apply(new LCApplicationStartedEvent(command.getId(),
                command.getApplicantId(), command.getClientReference()));
    }
    //..
}
....

Let's write an event processing component which will listen to this event and construct a query model. When working with the Axon framework, we have a convenient way to do this by annotating the event listening method with the `@EventHandler` annotation.

[source,java,linenum]
....
import org.axonframework.eventhandling.EventHandler;
import org.springframework.stereotype.Component;

@Component
class LCApplicationStartedEventHandler {

    @EventHandler                                      // <1>
    public void on(LCApplicationStartedEvent event) {
        LCView view = new LCView(event.getId(),
                        event.getApplicantId(),
                        event.getClientReference(),
                        event.getState());             // <2>
        // Perform any transformations to optimize access
        repository.save(view);                         // <3>
    }
}
....
<1> To make any method an event listener, we annotate it with the `@EventHandler` annotation.
<2> The handler method needs to specify the event that we intend to listen to. There are other arguments that are supported for event handlers. Please refer to the Axon framework documentation for more information.
<3> We finally save the view into an appropriate query store. When persisting this data, we should consider storing it in a form that is optimized for data access. In other words, we want to reduce as much complexity and cognitive load when querying this data.

NOTE: The `@EventHandler` annotation should not be confused with the `@EventSourcingHandler` annotation which we looked at in chapter 5. The `@EventSourcingHandler` annotation is used to replay events and restore aggregate state when loading event-sourced aggregates on the command side, whereas the `@EventHandler` annotation is used to listen to events outside the context of the aggregate. In other words, the `@EventSourcingHandler` annotation is used exclusively within aggregates, whereas the `@EventHandler` annotation can be used anywhere there is a need to consume domain events. In this case, we are using it to construct a query model.

==== Query side persistence choices
Segregating the query side this way enables us to choose a persistence technology most appropriate for the problem being solved on the query side. For example, if extreme performance and simple filtering criteria are prime, it may be prudent to choose an in-memory store like Redis or Memcached. If complex search/analytics requirements and large datasets are to be supported, then we may want to consider something like ElasticSearch. Or we may even simply choose to stick with just a relational database. The point we would like to emphasize is that employing CQRS affords a level of flexibility that was previously not available to us.

==== Exposing a query API
Applicants like to view the LCs they created, specifically those in the draft state. Let's look at how we can implement this functionality. Let's start by defining a simple object to capture the query criteria:

[source,java,linenum]
....
import org.springframework.data.domain.Pageable;

public class MyDraftLCsQuery {

    private ApplicantId applicantId;
    private Pageable page;

    // Getters and setters omitted for brevity
}
....

Let's implement the query to retrieve the results for these criteria:

[source,java,linenum]
....
import org.axonframework.queryhandling.QueryHandler;

public interface LCViewRepository extends JpaRepository<LCView, LCApplicationId> {

    Page<LCView> findByApplicantIdAndState(         // <1>
            String applicantId,
            LCState state,
            Pageable page);

    @QueryHandler                                   // <2>
    default Page<LCView> on(MyDraftLCsQuery query) {
        return findByApplicantIdAndState(           // <3>
                query.getApplicantId(),
                LCState.DRAFT,
                query.getPage());
    }
}
....
<1> This is the dynamic spring data finder method we will use to query the database.
<2> The `@QueryHandler` annotation provided by Axon framework routes query requests to the respective handler.
<3> Finally, we invoke the finder method to return results.

To connect this to the UI, we add a new method in the `BackendService` (originally introduced in Chapter 6) to invoke the query as shown here:

[source,java,linenum]
....
import org.axonframework.queryhandling.QueryGateway;

public class BackendService {

    private final QueryGateway queryGateway;                    // <1>

    public List<LCView> findMyDraftLCs(String applicantId) {
        return queryGateway.query(                              // <2>
                new MyDraftLCsQuery(applicantId),
                        ResponseTypes.multipleInstancesOf(LCView.class))
                .join();

    }
}
....
<1> The Axon framework provides the `QueryGateway` convenience that allows us to invoke the query. For more details on how to use the `QueryGateway`, please refer to the Axon framework documentation.
<2> We execute the query using the `MyDraftLCsQuery` object to return results.

What we looked at above, is an example of a very simple query implementation where we have a single `@QueryHandler` to service the query results. This implementation returns results as a one-time fetch. Let's look at more complex query scenarios.

==== Advanced query scenarios
Our focus currently is on active LC applications. Maintaining issued LCs happens in a different bounded context of the system. Consider a scenario where we need to provide a consolidated view of currently active LC applications and issued LCs. In such a scenario, it is necessary to obtain this information by querying two distinct sources (ideally in parallel) -- commonly referred to as the https://www.enterpriseintegrationpatterns.com/BroadcastAggregate.html[scatter-gather]footnote:[https://www.enterpriseintegrationpatterns.com/BroadcastAggregate.html] pattern. Please refer to the section on scatter-gather queries in the Axon framework documentation for more details.

In other cases, we may want to remain up to date on dynamically changing data. For example, consider a real-time stock ticker application tracking price changes. One way to implement this is by polling for price changes. A more efficient way to do this is to push price changes as and when they occur -- commonly referred to as the https://www.enterpriseintegrationpatterns.com/PublishSubscribeChannel.html[publish-subscribe]footnote:[https://www.enterpriseintegrationpatterns.com/PublishSubscribeChannel.html] pattern. Please refer to the section on subscription queries in the Axon framework documentation for more details.

=== Historic event replays
The example we have looked at thus far allows us to listen to events as they occur. Consider a scenario where we need to build a new query from historic events to satisfy an unanticipated new requirement. This new requirement may necessitate the need to create a new query model or in a more extreme case, a completely new bounded context. Another scenario might be when we may need to correct a bug in the way we had built an existing query model and now need to recreate it from scratch. Given that we have a record of all events that have transpired in the event store, we can use replay events to enable us to construct both new and/or correct existing query models with relative ease.

NOTE: We have used the term _event replay_ in the context of reconstituting state of event-sourced aggregate instances. The event replay mentioned here, although similar in concept, is still very different. In the case of domain object event replay, we work with a single aggregate root instance and only load events for that one instance. In this case though, we will likely work with events that span more than one aggregate.

Let's look at how the different types of replays and how we can use each of them.

==== Types of replays
When replaying events, there are at least two types of replays depending on the requirements we need to meet. Let's look at each type in turn:

* *Full event replay* is one where we replay all the events in the event store. This can be used in a scenario where we need to support a completely new bounded context which is dependent on this sub-domain. This can also be used in cases where we need to support a completely new query model or reconstruct an existing, erroneously built query model. Depending on the number of events in the event store, this can be a fairly long and complex process.

* *Partial/Adhoc event replay* is one where we need to replay all the events on a subset of aggregate instances or a subset of events on all aggregate instances or a combination of both. When working with partial event replays, we will need to specify filtering criteria to select subsets of aggregate instances and events. This means that the event store needs to have the flexibility to support these use cases. Using specialized event store solutions (like https://axoniq.io/product-overview/axon[Axon Server]footnote:[https://axoniq.io/product-overview/axon] and https://www.eventstore.com/eventstoredb[EventStoreDB]footnote:[https://www.eventstore.com/eventstoredb] to name a few) can be extremely beneficial.

==== Event replay considerations

===== Application availability

===== Optimization techniques

===== Event upcasting