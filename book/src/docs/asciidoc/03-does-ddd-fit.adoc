ifndef::imagesdir[:imagesdir: images]
[.text-justify]

[#_where_does_ddd_fit]
== Where and How Does DDD Fit? (15 pages)

[quote,Bob Goff]
We wonâ€™t be distracted by comparison if we are captivated with purpose.

Software architecture refers to the fundamental structures of a software system and the discipline of creating such structures and systems. Over the years, we have accumulated a series of architecture styles to help us deal with system complexity. In this chapter we will examine how DDD compares with several of these architecture styles and how/where it fits in the overall scheme of things when crafting a software solution.

=== Architecture Styles

=== Layered Architecture
The layered architecture is one of the most common architecture styles where the solution is typically organized into four broad categories: *presentation*, *application*, *domain* and *persistence*. Each of the layers provides a solution to a particular concern it represents as shown here:

.Essence of a layered architecture.
[.text-center]
image::architecture-styles/layered.png[]

The main idea behind the layered architecture is a separation of concerns -- where the dependencies between layers are unidirectional (from the top to the bottom). For example, the domain layer can depend on the persistence layer, not the other way round. In addition, any given layer typically accesses the layer immediately beneath it without bypassing layers in between. For example, the presentation layer may access the domain layer only through the application layer.

This structure enables looser coupling between layers and allows them to evolve independently of each other. The idea of the layered architecture fits very well with domain-driven design's tactical design elements as depicted here:

.Layered architecture mapped to DDD's tactical design elements.
[.text-center]
image::architecture-styles/layered-vs-ddd.png[]

DDD actively promotes the use of a layered architecture, primarily because it makes it possible to focus on the domain layer in isolation of other concerns like how to information gets displayed, how end-to-end flows are managed, how data is stored and retrieved, etc. From that perspective, solutions that apply DDD tend to naturally be layered as well.

However, any architecture approach we choose comes with its set of tradeoffs and limitations. We discuss some of these here.

==== Considerations

===== Layer cake anti-pattern
Sticking to a fixed set of layers provides a level of isolation, but in simpler cases, it may prove overkill without adding any perceptible benefit other than adherence to an agreed on architectural guidelines. In the layer cake anti-pattern, each layer merely proxies the call to the layer beneath it without adding any value. The example below illustrates this scenario that is fairly common:

.Example of the *layer cake* anti-pattern to find an entity representation by ID
[.text-center]
[plantuml,layer-cake-anti-pattern]
....
skinparam backgroundColor #EEEBDC
skinparam handwritten true

@startuml
skinparam handwritten true
skinparam sequence {
  ActorFontName "Gloria Hallelujah"
  ActorFontSize 20

  ArrowFontName "Gloria Hallelujah"
  ArrowFontSize 20
}
skinparam DatabaseFontName "Gloria Hallelujah"
skinparam DatabaseFontSize 20
skinparam DatabaseBorderColor darkred

skinparam Participant {
  FontName "Gloria Hallelujah"
  FontSize 20
}
actor "U I" as ui
participant Controller as c
participant Service as s
participant Repository as r
database Database as data


activate ui
ui -> c: findById
activate c
c -> s: findById
activate s
s -> r: findById
activate r
r -> data: findById
activate data
data -> r: Entity
deactivate data
r -> s: Entity
deactivate r
s -> c: Entity
deactivate s
c -> ui: Entity
deactivate c
deactivate ui
@enduml
....

Here the `findById` method is replicated in every layer and simply calls the method with the same name in the layer below with no additional logic. This introduces a level of accidental complexity to the solution. Some amount of redundancy in the layering may be unavoidable for the purposes of standardization. It may be best to re-examine the layering guidelines if the _layer cake_ occurs prominently in the codebase.

===== Anemic translation
Another variation of the layer cake we see commonly is one where layers refuse to share input and output types in the name of higher isolation and looser coupling. This makes it necessary to perform translations at the boundary of each layer. If the objects being translated are more or less structurally identical, we have an _anemic translation_. Let's look at a variation of the `findById` example we discussed above.

.Example of the *anemic translation* anti-pattern to find an entity representation by ID
[.text-center]
[plantuml,layer-cake-anti-pattern]
....
skinparam backgroundColor #EEEBDC
skinparam handwritten true

@startuml
skinparam handwritten true
skinparam sequence {
  ActorFontName "Gloria Hallelujah"
  ActorFontSize 20

  ArrowFontName "Gloria Hallelujah"
  ArrowFontSize 20
}
skinparam DatabaseFontName "Gloria Hallelujah"
skinparam DatabaseFontSize 20
skinparam DatabaseBorderColor darkred

skinparam Participant {
  FontName "Gloria Hallelujah"
  FontSize 20
}
actor "U I" as ui
box "Bounded Context" #LightYellow
participant Controller as c
participant Service as s
participant Repository as r
database Database as data
end box

activate ui
ui -> c: findById
activate c
c -> s: findById
activate s
s -> r: findById
activate r
r -> data: findById
activate data
data -> r: db.Entity
deactivate data
r -> s: service.Entity
deactivate r
s -> c: controller.Entity
deactivate s
c -> ui: ui.Entity
deactivate c
deactivate ui
@enduml
....
In this case, each layer defines a `Entity` type of its own, requiring a translation between types at each layer. To make matters worse, the structure of the `Entity` type may have seemingly minor variations (for example, `lastName` being referred to as `surname`). While such translations may be necessary across bounded contexts, teams should strive to avoid the need for variations in names and structures of the same concept within a single bounded context. The intentional use of the *ubiquitous language* helps avoid such scenarios.

===== Layer bypass
When working with a layered architecture, it is reasonable to start by being strict about layers only interacting with the layer immediately beneath it. As we have seen above, such rigid enforcements may lead to an intolerable degree of accidental complexity, especially when applied generically to a large number of use-cases. In such scenarios, it may be worth considering consciously allowing one or more layers to be bypassed. For example, the `controller` layer may be allowed to work directly with the `repository` without using the `service` layer.

This can be a slippery slope. To continue maintaining a level of sanity, teams should consider the use of a lightweight architecture governance tool like https://www.archunit.org/[*ArchUnit*]footnote:[https://www.archunit.org/] to make agreements explicit and afford quick feedback. A simple example of how to use ArchUnit for this purpose is shown here:

[source,java,linenum]
....
class LayeredArchitectureTests {
    @ArchTest
    static final ArchRule layer_dependencies_are_respected_with_exception = layeredArchitecture()

            .layer("Controllers").definedBy("..controller..")
            .layer("Services").definedBy("..service..")
            .layer("Domain").definedBy("..domain..")
            .layer("Repository").definedBy("..repository..")

            .whereLayer("Controllers").mayNotBeAccessedByAnyLayer()
            .whereLayer("Services").mayOnlyBeAccessedByLayers("Controllers")
            .whereLayer("Domain").mayOnlyBeAccessedByLayers("Services", "Repository", "Controllers")
            .whereLayer("Repository")
                .mayOnlyBeAccessedByLayers("Services", "Controllers"); // <1>
}
....
<1> The Repository layer can be accessed by both the Services and Controllers layers -- effectively allowing Controllers to bypass the use of the Services layer.

=== Onion Architecture

=== Hexagonal Architecture

=== Service Oriented Architecture (SOA)
Service Oriented Architecture (SOA) is an architectural style where software components expose (potentially) reusable functionality over standardized interfaces. The use of standardized interfaces (such as SOAP, REST, gRPC, etc. to name a few) enables easier interoperability when integrating heterogeneous solutions. Previously, the use of non-standard, proprietary interfaces made this kind of integration a lot more challenging. For example, a retail bank may expose inter-account transfer functionality in the form of RESTful web services.

.SOA: Expose reusable functionality over standard interfaces.
[.text-center]
image::architecture-styles/architecture-styles-soa.png[]

While SOA prescribes exposing functionality over standardized interfaces, the focus is more on integrating heterogeneous applications than on implementing them. At one of the banks I worked at, we exposed a set of over 500 service interfaces over SOAP. Under the covers, we implemented these using EJB 2.0 which largely delegated most if not all the logic to a set of underlying stored procedures within a single monolithic Oracle database! Indeed, we advertised this implementation as an example of SOA and it would be hard to argue that it was not. However, our implementation of SOA


=== Microservice Architecture

=== Event-Driven Architecture (EDA)

[#_cqrs_pattern]
=== Command Query Responsibility Segregation (CQRS)
In traditional applications, a single domain, data/persistence model is used to handle all kinds of operations. With CQRS, we create distinct models to handle updates (commands) and enquiries. This is depicted in the following diagram:

.Traditional versus CQRS Architecture
image::cqrs/traditional-vs-cqrs-architecture.png[]

NOTE: We depict multiple query models above because it is possible (but not necessary) to create more than one query model, depending on the kinds of query use cases that need to be supported.

For this to work predictably, the query model(s) need to be kept in sync with the write models (we will examine some of the techniques to do that in detail later.

[#_when_to_use_cqrs]
==== When to use CQRS?
The traditional, single-model approach works well for simple, CRUD-style applications, but starts to become unwieldy for more complex scenarios. We discuss some of these scenarios below:

* *Volume imbalance between read and writes*: In most systems, read operations often outnumber write operations by significant orders of magnitude. For example, consider the number of times a trader checks stock prices vs. the number of times they actually transact (buy or sell stock trades). It is also usually true that write operations are the ones that make businesses money. Having a single model for both reads and writes in a system with a majority of read operations can overwhelm a system to an extent where write performance can start getting affected.

* *Need for multiple read representations*: When working with relatively complex systems, it is not uncommon to require more than one representation of the same data. For example, when looking at personal health data, one may want to look at a daily, weekly, monthly view. While these views can be computed on the fly from the _raw_ data, each transformation (aggregation, summarization, etc.) adds to the cognitive load on the system. Several times, it is not possible to predict ahead of time, the nature of these requirements. By extension, it is not feasible to design a single canonical model that can provide answers to all these requirements. Creating domain models specifically designed to meet a focused set of requirements can be much easier.

* *Different security requirements*: Managing authorization and access requirements to data/APIs when working a single model can start to become cumbersome. For example, higher levels of security may be desirable for debit operations in comparison to balance enquiries. Having distinct models can considerably ease the complexity in designing fine-grained authorization controls.

* *More uniform distribution of complexity*: Having a model dedicated to serve only command-side use cases means that they can now be focused towards solving a single concern. For query-side use cases, we create models as needed that are distinct from the command-side model. This helps spread complexity more uniformly over a larger surface area -- as opposed to increasing the complexity on the single model that is used to serve all use cases. It is worth noting that the essence of domain-driven design is mainly to work effectively with complex software systems and CQRS fits well with this line of thinking.

=== Serverless architecture

[#_big_ball_of_mud]
=== Big ball of mud
