== Implementing the User Interface -- Task-based (20 pages)
[quote, Marty Rubin]
To accomplish a difficult task, one must first make it easy.

The essence of DDD is a lot about capturing the business process and user intent a lot more closely. In the previous chapter, we designed a set of APIs without paying a lot of attention to how those APIs would get consumed by its eventual users. In this chapter, we will design the GUI for the LC application using the https://openjfx.com/[JavaFX]footnote:[https://openjfx.com/] framework. As part of that, we will examine how this approach of designing APIs in isolation can cause an impedance mismatch between the producers and the consumers. We will examine the consequences of this _impedance mismatch_ and how task-based UIs can help cope with this mismatch a lot better.

At the end of the chapter, you will learn how to employ DDD principles to help you build robust user experiences that are simple and intuitive. You will also learn why it may be prudent to design your backend APIs from the perspective of the consumer.

=== Technical Requirements
* JDK 1.8+ (We have used Java 16 to compile sample sources)
* JavaFX SDK 16 and SceneBuilder
* Maven 3.x
* Spring Boot 2.4.x
* mvvmFX 1.8 (https://sialcasa.github.io/mvvmFX/)
* JUnit 5.7.x (Included with spring boot)
* TestFX (for UI testing)
* OpenJFX Monocle (for headless UI testing)
* Project Lombok (To reduce verbosity)

=== Bootstrapping the UI
We will simply be building on top of the LC application we created in Chapter 5: Implementing Domain Logic. For detailed instructions, refer to the section on Bootstrapping the Application. In addition, we will need to add the following dependencies to the `dependencies` section of the Maven `pom.xml` file in the root directory of the project:

[source,xml,linenum]
----
<dependencies>
    <!--...-->
    <dependency>
        <groupId>org.openjfx</groupId>
        <artifactId>javafx-controls</artifactId>
        <version>${javafx.version}</version>
    </dependency>
    <dependency>
        <groupId>org.openjfx</groupId>
        <artifactId>javafx-graphics</artifactId>
        <version>${javafx.version}</version>
    </dependency>
    <dependency>
        <groupId>org.openjfx</groupId>
        <artifactId>javafx-fxml</artifactId>
        <version>${javafx.version}</version>
    </dependency>
    <dependency>
        <groupId>de.saxsys</groupId>
        <artifactId>mvvmfx</artifactId>
        <version>${mvvmfx.version}</version>
    </dependency>
    <dependency>
        <groupId>de.saxsys</groupId>
        <artifactId>mvvmfx-spring-boot</artifactId>
        <version>${mvvmfx.version}</version>
    </dependency>
    <!--...-->
</dependencies>
----

To run UI tests, you will need to add the following dependencies:
[source,xml,linenum]
----
<dependencies>
    <!--...-->
    <dependency>
        <groupId>org.testfx</groupId>
        <artifactId>testfx-junit5</artifactId>
        <scope>test</scope>
        <version>${testfx-junit5.version}</version>
    </dependency>
    <dependency>
        <groupId>org.testfx</groupId>
        <artifactId>openjfx-monocle</artifactId>
        <version>${openjfx-monocle.version}</version>
    </dependency>
    <dependency>
        <groupId>de.saxsys</groupId>
        <artifactId>mvvmfx-testing-utils</artifactId>
        <version>${mvvmfx.version}</version>
        <scope>test</scope>
    </dependency>
    <!--...-->
</dependencies>
----

To be able to run the application from the command line, you will need to add the `javafx-maven-plugin` to the `plugins` section of your `pom.xml`, per the following:
[source,xml,linenum]
----
<plugin>
    <groupId>org.openjfx</groupId>
    <artifactId>javafx-maven-plugin</artifactId>
    <version>${javafx-maven-plugin.version}</version>
    <configuration>
        <mainClass>com.premonition.lc.issuance.App</mainClass>
    </configuration>
</plugin>
----
To run the application from the command line, use:
[source,bash]
----
mvn javafx:run
----

NOTE: If you are using a JDK greater that version 1.8, the JavaFX libraries may not be bundled with the JDK itself. When running the application from your IDE, you will likely need to add the following:
[source,bash]
----
--module-path=<path-to-javafx-sdk>/lib/ \
   --add-modules=javafx.controls,javafx.graphics,javafx.fxml,javafx.media
----

NOTE: Please refer to the ch06 directory of the accompanying source code repository for the complete example.

Before we dive deep into building the GUI solution, let's do a quick recap of where we left the APIs.

=== CRUD-based versus task-based UIs

If you recall from chapter 5, we created the following commands:
[.text-center]
[plantuml,potential-commands]
....
@startuml
skinparam handwritten true
skinparam CloudFontName "Gloria Hallelujah"
cloud Commands {
    cloud "Create LC Application" as St
    cloud "Update LC Application" as U
    cloud "Submit LC Application" as Su
    cloud Validate as V {
        cloud "Validate Product" as VP
        cloud "Validate Applicant" as VA
    }
    cloud "Approve LC Application" as AA
    cloud "Decline LC Application" as DA
    cloud "Issue LC" as I

   St -down-> U
   U -down-> U
   U -down-> Su
   Su -down-> V
   V -right-> AA
   V --> DA
   AA --> I

}
@enduml
....
If you observe carefully, there seem to be commands at two levels of granularity. The "Create LC Application" and "Update LC application" are coarse grained, whereas the others are a lot more focused in terms of their intent. One possible decomposition of the coarse grained commands can be as depicted here:

[.text-center]
[plantuml,revised-commands]
....
@startuml
skinparam handwritten true
skinparam CloudFontName "Gloria Hallelujah"
cloud "Old Commands" as Old {
    cloud "Update LC Application"
    cloud "Create LC Application"
}

cloud "New Commands" as New {
    cloud "Start LC Application"
    cloud "Add / Update Beneficiary"
    cloud "Add / Update Advising Bank"
    cloud "Add / Update Merchandise"
    cloud "Add / Update Documents"
    cloud "Add / Update Conditions"
}

Old -down-> New
@enduml
....

In addition to just being more fine-grained than the commands in the previous iteration, the revised commands seem to better capture the user's intent. This may feel like a minor change in semantics, but can have a huge impact on the way our solution is used by its ultimate end-users. The question then is whether we should _always_ prefer fine-grained APIs over coarse grained ones. The answer can be a lot more nuanced. Let's examine

==== CRUD-based experiences

==== Task-based experiences

==== Impact on APIs and user experiences

==== Task-based or CRUD-based?

Task-based UIs (in contrast to CRUD-based UIs) treat user intents as first class citizens and perpetrate the spirit of DDD's ubiquitous language very elegantly.

=== Design pattern considerations

==== Usability

==== Testability

=== Implementing the save LC functionality

=== Invoking backend services

=== Summary

=== Questions

=== Further reading

[cols="3,3,6"]
|===
|Title |Author |Location

|TODO
|TODO
|TODO
|===
