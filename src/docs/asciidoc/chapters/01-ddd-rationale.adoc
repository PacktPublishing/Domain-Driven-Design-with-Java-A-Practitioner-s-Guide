ifndef::imagesdir[:imagesdir: ../images]
:icons: font

== The Rationale for Domain-Driven Design (15 pages)

[quote, Frank Sonnenberg, "Soul Food: Change Your Thinking, Change Your Life"]
Before acting on any recommendation, know the rationale.

According to the Project Management Institute's (PMI) _Pulse of the Profession_ report published in February 2020, only *77%* of all projects meet their intended goals -- and even this is true only in the most mature organizations. For less mature organizations, this number falls to just *56%* i.e. approximately one in every two projects does not meet its intended goals.

[#img-project-statistics]
.Project Success -- By the numbers
[link=https://www.pmi.org/learning/library/forging-future-focused-culture-11908,window=_blank]
image::https://www.pmi.org/kasimage/86ec8e38-f691-4fdd-ba92-0be79ddc1965/10.jpg[Project Statistics]

Furthermore, approximately one in every five projects is declared an outright failure. At the same time, we also seem to be embarking on our most ambitious and complex projects.

In this chapter, we will examine the main causes for project failure and look at how applying domain-driven design provides a set of guidelines and techniques to improve the odds of success in our favor. While Eric Evans wrote his classic book on the subject way back in 2003, we look at why that work is still extremely relevant in today's times.

=== Why Do Software Projects Fail?

[quote,Henry Ford]
Failure is simply the opportunity to begin again, this time more intelligently.

According to the https://www.pmi.org/learning/library/project-success-definitions-measurement-techniques-5460[project success report]footnote:project-success[Pinto, J. K. & Slevin, D. P. (1988). Project success: definitions and measurement techniques. Project Management Journal, 19(1), 67â€“72.]  published in the Project Management Journal of the PMI, the following six factors need to be true for a project to be deemed successful:

.Project Success Factors
[%autowidth.stretch]
|===
|Category |Criterion |Description

.3+|Project
|Time
|It meets the desired time schedules

|Cost
|Its cost does not exceed budget

|Performance
|It works as intended

.3+|Client
|Use
|Its intended clients use it

|Satisfaction
|Its intended clients are happy

|Effectiveness
|Its intended clients derive direct benefits through its implementation

|===

With all of the above criteria being applied to assess project success, a large percentage of projects fail for one reason or another. Let's examine some of the top reasons in more detail:

==== Inaccurate Requirements
This chart below, derived from PMI's __Pulse of the Profession__footnote:project-failure-causes[https://www.pmi.org/-/media/pmi/documents/public/pdf/learning/thought-leadership/pulse/pulse-of-the-profession-2017.pdf?sc_lang_temp=en] report from 2017 highlights seems to highlight a very starking fact -- inaccurate or misinterpreted requirements cause a very large portion of projects to fail.

.Project Failure Causes
[link=https://www.pmi.org/-/media/pmi/documents/public/pdf/learning/thought-leadership/pulse/pulse-of-the-profession-2017.pdf?sc_lang_temp=en,window=_blank]
image::project-failure-causes.png[scaledwidth=75%]

It follows that it is impossible to build something that clients can use, are happy with and makes them more effective at their jobs if the wrong thing gets built -- even much less for the project to be built on time, and under budget.

==== Silo Mentality
IT teams, especially in large organizations are staffed with mono-skilled roles such as UX designer, developer, tester, architect, business analyst, project manager, product owner, business sponsor, etc. In a lot of cases, these people are parts of distinct organization units/departments -- each with its own set of priorities and motivations. To make matters even worse, the geographical separation between these people only keeps increasing. The need to keep costs The current COVID-19 ecosystem does not help matters either.

.Silo mentality and the loss of information fidelity
image::silo-mentality.png[scaledwidth=75%]

All this results in a loss in fidelity of information at every stage in the _assembly line_, which then results in misconceptions, inaccuracies, delays and eventually failure!

==== The (Ab)use of Agile Architecture
Agile software delivery methods manifested themselves in the late 90s, early 2000s in response to heavyweight processes collectively known as _waterfall_. These processes seemed to favor https://en.wikipedia.org/wiki/Big_Design_Up_Front[big design up front] (https://en.wikipedia.org/wiki/Big_Design_Up_Front) and abstract ivory tower thinking based on wishful, ideal world scenarios. This was based on the premise that thinking things out well in advance ends up saving serious development headaches later on as the project progresses.

In contrast, agile methods seem to favor a much more nimble and iterative approach to software development with a high focus on working software over other artifacts such as documentation. Most teams these days claim to practice some form of iterative software development. However, this obsession to claim conformance to a specific https://thedigitalprojectmanager.com/agile-methodologies[agile methodologies] (https://thedigitalprojectmanager.com/agile-methodologies) as opposed to the underlying principles, a lot of teams misconstrue having just enough architecture with having no perceptible architecture. This results in a situation where adding new features or enhancing existing ones takes a lot longer than what it previously used to -- which then accelerates the devolution of the solution to become the dreaded http://www.laputan.org/mud/mud.html#BigBallOfMud[big ball of mud] (http://www.laputan.org/mud/mud.html#BigBallOfMud).

==== Excessive Incidental Complexity
Mike Cohn popularized the notion of the https://www.mountaingoatsoftware.com/blog/the-forgotten-layer-of-the-test-automation-pyramid[test pyramid] (https://www.mountaingoatsoftware.com/blog/the-forgotten-layer-of-the-test-automation-pyramid) where he talks about how a large number of unit tests should form the foundation of a sound testing strategy -- with numbers decreasing significantly as one moves up the pyramid. The rationale here is that as one moves up the pyramid, the cost of upkeep goes up copiously while speed of execution slows down manifold. In reality though, a lot of teams seem to adopt a strategy that is the exact opposite of this -- known as the testing ice cream cone as depicted below:

.Testing Strategy: Expectation vs. Reality
image::test-pyramid-reality.png[]

The testing ice cream cone is a classic case of what Fred Brooks calls incidental complexity in his seminal paper titled http://faculty.salisbury.edu/~xswang/Research/Papers/SERelated/no-silver-bullet.pdf[No Silver Bullet -- Essence and Accident in Software Engineering] (http://faculty.salisbury.edu/~xswang/Research/Papers/SERelated/no-silver-bullet.pdf).

All software has some amount of https://en.wikipedia.org/wiki/Essential_complexity[essential complexity] (https://en.wikipedia.org/wiki/Essential_complexity) that is inherent to the problem being solved. This is especially true when creating solutions for non-trivial problems.  However, incidental or accidental complexity is not directly attributable to the problem itself -- but is caused by limitations of the people involved, their skill levels, the tools and/or abstractions being used. Not keeping tabs on incidental complexity causes teams to veer away from focusing on the real problems, solving which provide the most value. It naturally follows that such teams minimize their odds of success appreciably.

==== Uncontrolled Technical Debt
Financial debt is the act of borrowing money from an outside party to quickly finance the operations of a business -- with the promise to repay the principal plus the agreed upon rate of interest in a timely manner. Under the right circumstances, this can accelerate the growth of a business considerably while allowing the owner to retain ownership, reduced taxes and lower interest rates. On the other hand, the inability to pay back this debt on time can adversely affect credit rating, result in higher interest rates, cash flow difficulties, and other restrictions.

Technical debt is what results when development teams take arguably sub-optimal actions to expedite the delivery of a set of features or projects. For a period of time, just like borrowed money allows you to do things sooner than you could otherwise, technical debt can result in short term speed. In the long term, however, software teams will have to dedicate a lot more time and effort towards simply managing complexity as opposed to thinking about producing architecturally sound solutions. This can result in a vicious negative cycle as illustrated in the diagram below:

.Technical Debt -- Implications
[plantuml,tech-debt]
....
@startuml
skinparam handwritten true
skinparam monochrome true

state "Software Project" as Project {
  state S1 as "Low Morale and Motivation"
  state S2 as "Low Code Quality"
  state S3 as "High Technical Debt"
  state S4 as "Pressure to increase productivity"
  state S5 as "Lower Productivity"
  S1 --> S2 : Leads to
  S3 -right--> S1 : Leads to
  S1 -right--> S5 : Leads to
  S4 -down--> S3 : Leads to
  S3 -down--> S2 : Refers to
  S5 -up-> S4 : Leads to
  S2 -up-> S5 : Leads to
}
Project --right[dashed]--> Fail : Leads to
@enduml
....

In a recent https://www.mckinsey.com/business-functions/mckinsey-digital/our-insights/tech-debt-reclaiming-tech-equity[McKinsey survey] (https://www.mckinsey.com/business-functions/mckinsey-digital/our-insights/tech-debt-reclaiming-tech-equity) sent out to CIOs, around 60% reported that the amount of tech debt increased over the past three years. At the same time, over 90% of CIOs allocated less than a fifth of their tech budget towards paying it off. Martin Fowler explores the deep correlationfootnote:fowler-quality-cost[https://martinfowler.com/articles/is-quality-worth-cost.html#WeAreUsedToATrade-offBetweenQualityAndCost] between high software quality (or the lack thereof) and the ability to enhance software predictably. While carrying a certain amount of tech debt is inevitable and part of doing business, not having a plan to systematically pay off this debt can have significantly detrimental effects on team productivity and ability to deliver value.

=== Modern Systems and Dealing with Complexity

[quote,Albert Einstein]
We can not solve our problems with the same level of thinking that created them.

We find ourselves in the midst of the fourth industrial revolution where the world is becoming more and more digital -- with technology being a significant driver of value for businesses. Exponential advances in computing technology as illustrated by Moore's Law below,

.Moore's Law
image:moores-law.png[alt=Moore's Law]

along with the rise of the internet as illustrated below,

.Global Internet Traffic
image:global-internet-traffic.png[alt=Global Internet Traffic]
 has meant that companies are being required to modernize their software systems much more rapidly than they ever have. Along with all this, the onset of commodity computing services such as the public cloud has led to a move away from expensive centralized computing systems to more distributed computing ecosystems. As we attempt building our most complex solutions, monoliths are being replaced by an environ of collaborating microservices.

As we enter an age of encountering our most complex business problems, we need to embrace new ways of thinking, a development philosophy and an arsenal of techniques to iteratively evolve mature software solutions that will stand the test of time. Domain-driven design promises to provide answers. In the rest of this book, we will examine what DDD is and why it is indispensable when working to provide solutions for non-trivial problems in today's world of massively distributed teams and applications.

=== What is Domain-Driven Design?

[quote,Confucius]
Life is really simple, but we insist on making it complicated.

In the previous section, we saw how an inaccurate understanding of business requirements, team silos, technical debt, etc. coupled with system complexity get in the way of software project success. The idea of domain-driven design, originally conceived by Eric Evans in his 2003 book, is an approach to software development that focuses on expressing software solutions in the form of a model that closely embodies the core of the problem being solved. It provides a set of systematic techniques to analyze, architect and implement software solutions in a manner that enhances chances of success. While Evans' work was indeed seminal, ground-breaking and way ahead of its time, over the years, practical application has continued to remain a challenge. In this section, we will look at some of the foundational terms and concepts behind domain-driven design. Elaboration and practical application of these concepts will happen in upcoming chapters of this book.

==== What is a Domain?

The foundational concept when working with domain-driven design is the notion of a domain. But then what exactly is a domain? The word https://en.wiktionary.org/wiki/domain[#_domain_#] which has its https://www.etymonline.com/word/domain[origins] in the 1600s to the Old French word _domaine_ (power), Latin word _dominium_ (property, right of ownership) is a rather confusing word. Depending on who, when, where and how it is used, it can mean different things:

.Domain: Means many things depending on context
[link=https://en.wiktionary.org/wiki/domain#Noun,window=_blank]
image::domain-definition.png[Domain,scaledwidth=75%]

In the context of a business however, the word domain covers the overall scope of its primary activity -- the service it provides to its customers. For example, Tesla operates in the domain of electric vehicles, Netflix provides online movies and shows, while McDonald's provides fast food. Some companies like Amazon, provide services in more than one domain -- online retail, cloud computing, among others.

==== Domain Experts
TODO

==== What is a Subdomain?
The domain of a business (at least the successful ones) almost always encompasses fairly complex and abstract concepts. With a view to better deal with this complexity, domain-driven design advises decomposing the domain of a business into multiple manageable parts called *subdomains*. This facilitates better understanding and makes it easier to arrive at a solution. For example, the online retail domain may be divided into subdomains such as product, inventory, rewards, shopping cart, order management, payments, shipping, etc.

.Subdomains in the Retail domain
[plantuml,domains]
....
@startuml
skinparam handwritten true
usecase Products
usecase Inventory
usecase Rewards
usecase "Shopping Cart"
usecase "Online Orders"
usecase Payments
usecase Shipping
usecase Identity
usecase Logging
usecase "Activity Tracking"
cloud "<b>..................." as c2
@enduml
....

In certain businesses, subdomains themselves may turn out to become very complex on their own and may require further decomposition. For example, in the retail example above, it may be required to break the products subdomain into further constituent subdomains such as catalog, search, recommendations, reviews, etc.

.Subdomains in the Products subdomain
[plantuml,subdomains]
....
@startuml
skinparam handwritten true
usecase Catalog
usecase Search
usecase Recommendations
usecase Reviews
@enduml
....

==== Types of Subdomains
Breaking down a complex domain into more manageable subdomains is a great thing to do. However, not all subdomains are created equal. With any business, the following three types of subdomains are going to be encountered:

* *Core*: The main focus area for the business. This is what provides the biggest differentiation and value. It is therefore natural to want to place the most focus on the core subdomain. In the retail example above, shopping cart and orders might be the biggest differentiation -- and hence may form the core subdomains for that business venture. It is prudent to implement core sub-domains in-house given that it is something that businesses will desire to have the most control over. In the online retail example above,
* *Supporting*: Like with every great movie, where it is not possible to create a masterpiece without a solid supporting cast, so it is with supporting or auxiliary subdomains. Supporting subdomains are usually very important and very much required, but may not be the primary focus to run the business. These supporting subdomains, while necessary to run the business, do not usually offer a significant competitive advantage. Hence it might be even fine to completely outsource this work or use an off-the-shelf solution as is or with minor tweaks. For the retail example above, assuming that online ordering is the primary focus of this business, catalog management may be a supporting subdomain.

* *Generic*: When working with business applications, one is required to provide a set of capabilities *not* directly related to the problem being solved. Consequently, it might suffice to just make use of an off-the-shelf solution For the retail example above, the identity, logging and activity tracking subdomains might fall in that category.

NOTE: It is important to note that the notion of core vs. supporting vs. generic subdomains is very context specific. What is core for one business may be supporting or generic for another.


==== Problem Domain vs. Solutions Domain


=== Why is DDD Relevant? Why Now?

[quote,Eric Evans]
Domain-driven design is even more relevant now.

TODO

=== Next Steps
TODO

=== Further Reading